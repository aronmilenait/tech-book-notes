# Chapter 1: Introduction

Writing computer software is one of the purest creative activities in the history of the human race. Programmers aren’t bound by practical limitations such as the laws of physics; we can create exciting virtual worlds with behaviors that could never exist in the real world. 
## Two general approaches to fight complexity:

1. Making code simpler and more obvious.
2. To encapsulate it, so that programmers can work on a system without being exposed to all of its complexity at once. This approach is called **modular design**. 
## Waterfall and Agile

In the **waterfall model**, a project is divided into discrete phases such as requirements definition, design, coding, testing, and maintenance. Each phase completes before the next phase starts. The entire system is designed at once, during the design phase.

The waterfall model rarely works well for software. Software systems are intrinsically more complex than physical systems; it isn’t possible to visualize the design for a large software system well enough to understand all of its implications before building anything. As a result, the initial design will have many problems.

Most software development projects today use an incremental approach such as **agile development**, in which the initial design focuses on a small subset of the overall functionality. By spreading out the design in this way, problems with the initial design can be fixed while the system is still small; later features benefit from experience gained during the implementation of earlier features, so they have fewer problems.

As a software developer, you should always be on the lookout for opportunities to improve the design of the system you are working on.
